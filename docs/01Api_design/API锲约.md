#### API设计浅谈



##### API锲约

陈氏指数 CEI —— 契约使用指数（Contract Employ Index），每百万使用者记为 1。CEI 越高，表明使用者越多，同样的，改动的代价就越大。

REST API（以下凡提到 API，都指 REST API）是什么？REST API 是服务器和客户端之间的契约。这就意味着一个中小规模的 API，其 CEI 起码在 0.1 以上。API 一旦发布，你基本失去了对其任意修改的权利，因为你无法期待脱离了掌控的客户端能够像我们希望的那样，步调一致地升级系统；

工具：

- Swagger
  - API 的文档化，API 的接口的可视化，各种语言的客户端类库的自动生成，甚至服务端代码也能够自动生成
  - **用 Swagger 定义的 API 来在编译时生成 Validation，可以保证文档和实现的一致性**，待验证；
- API blueprint
  - 更偏向 API 的文档化，所以它选择的描述语言是 markdown。三者之间 API blueprint 的描述语言可读性最强，更像是真的在撰写文档
- RAML
  -  使用 yaml 来描述 API。它被设计地很灵活，很容易把描述分解到多个文件里然后相互引用；

- Apiaaz.cc
- Postman

就描述语言来说，RAML 像是一个蓬勃向上的少年，精明而干练；而 swagger 已经垂垂老矣，冗长而乏味。我一开始在 RAML 和 swagger 两者间左右摇摆，写了不少测试代码，如果不是 swagger 的工具链过于吸引人，而 RAML 1.0 版本还处在 beta 阶段，我可能会最终选择 RAML。





涉及接口需要考虑： 

	- userability
	- simplicity
	- security
	- reliability等待

作用： 方便的描述API的输入输出，并生成交互式的API文档；

交互式API文档： 用户在读api文档的时候，可以在线运行API，获得结果；以便API的设计者就可以在还没有开始写代码的时候就反复推演API的结构，直到产生一个健壮的，清晰明了，可用性强的接口；



###### 契约和实现合二为一

如果我们从 swagger 出发，设计好 API 的接口，然后再用某种语言实现这个接口，显得有些累赘，日后改接口时，得改代码；改代码后如果变动了接口，还得回头改 swagger 的声明，这样太累心，迟早会出不一致的问题。一旦不一致，之前所做的所有努力就泡汤了：你提供了契约，却没有按照契约去行事。

swagger 考虑到了这一点，它能帮你生成客户端的 SDK 和服务器端的 stub。客户端的 SDK 还好，客户端的其他代码都是单向调用 SDK，重新生成并不会影响太大；服务端的代码需要 API 实现者实现，即便生成了 stub，肯定是要修改和添加功能的，所以如果修改 swagger 文档后，你不能再重新生成服务器端的 stub 了，因为这样有可能覆盖掉你已经修改的代码。所以大家使用 swagger 的方式基本都是服务器这端完全自己写，不用 stub。这样的话，上述的问题依旧存在。

另一种解决方案是通过 API 代码反向生成 swagger 文档。乍一看这似乎违背了 API 描述语言的初衷：我们竟然在没开始设计之前，就开始写代码了。

不必过虑。我们可以把代码的结构调整地更贴近描述语言。你可以先撰写代码把 API 的输入输出定义清楚，然后通过这个定义来生成 swagger 文档，在 swagger-ui 里面调试和验证；当借口设计符合期望后，再完成具体的实现。



通过代码反向生成 swagger 文档的好处是代码和文档总是一致的，API 的实现和契约相互印证；缺点是程序员看见代码就像看见九天仙女一样，眼迷心荡，刚定义好接口，还未细思，就忙不迭地去实现了。



##### API子系统



分类：

- 配置管理
- CLI
- 测试框架



###### 配置管理

​		一个系统的灵活度，和它的配置管理是离不开的。系统中存在的大量的预置的属性（下文简称 property），需要有一个公共的地方来放置。这里我不说「常量」，而是说「预置的属性」，是因为这属性可能需要在运行时发生改变，而常量的范畴会让人有所误解

​		把所有的 property 放在一个配置文件中，在系统启动的时候读入；

​	配置环境类型：

- ini

- json

- yaml

- toml	

  这些类型各有优劣，选择的时候注意**配置文件最好能够支持注释，便于维护**;



​	运行环境：

 - development

 - staging

 - production

 - test

   不同的运行时加载的配置文件可能不同。所以配置管理需要考虑这一点，让配置文件可以重载（override）。最常见的重载策略是系统提供一个公共的配置文件：default，然后各种运行时相关的配置文件继承并局部重载这个配置。在系统启动的时候，二者合并。

   有些时候，我们需要在系统运行的时候改写配置。由于配置一般在系统初始化的时候就被读入内存，所以单纯改写配置文件无法即时生效，这时，你需要像管理缓存一样去管理和配置相关的数据，将其封装在一个容器里：当配置被修改时，调用这个容器的 invalidate 方法 —— 这样，下次访问任意一个配置项时，会重新读入配置，并缓存起来。

   对于分布式的项目，配置应该集中存储在诸如 redis 这样的系统，以方便统一处理（orchestrate）

​	

- 如果你的注释遵循 javadoc，那么从代码里可以生产出来漂亮的文档（SDK）。
- facebook/infer 可以对你的代码做详细的 static analysis。
- jacoco 可以根据源码和 test case 生成 coverage report。



